#+TITLE: psel: Elisp backend for PureScript

* 動機

emacs を使っているが elisp (というか動的型言語一般)が苦手なため。
elisper に怒られるのでこっそりやる。

* FFI

2021/12/08
参考
https://discourse.purescript.org/t/asking-for-guides-of-making-new-backends/1126

forkする方式(purenix?)、対象言語のFFIを別リポで提供する([[https://github.com/andyarvanitis/purescript-native-go-ffi][purescript-native-go-ffi]])方式があるっぽい。
後者がいいかな..

core-fn.jsonは [[https://hackage.haskell.org/package/purescript-0.13.8/docs/Language-PureScript-CoreFn-FromJSON.html][moduleFromJSON]] で読み取るのだが、バージョン情報はあれどパッケージが分からん。
ということはパッケージ毎にFFIファイルを分けたかったが(e.g. purescript-prelude/Data.Eq.el)、
Data.Eq の core-fn.jsonを読み込んだ際、どのディレクトリを見れば分からない...(go-ffiはどう解決している？)
アノテーション(Ann)の中に情報入ってたりするのか？

ModulePath が持っていた。例えば Data.Eq の場合、次のような値が入っている。
(まあ spagoの実装依存のわけだが...)
: "modulePath":".spago/prelude/master/src/Data/Eq.purs"

その内状況は変わる可能性ありだが..
https://github.com/purescript/purescript/issues/2437
https://github.com/purescript/purescript/issues/3493

Data.Bar.ps は Data.Bar.el に変換することにした。
elisp の命名規約とは外れているが、そもそもPSから変換したコードなんてはみ出しているので、
逆に意識的にするために名前はelispの命名規約から外すほうがいいかな。
副作用としてFFIコードをインラインにする必要はなく、例えば Data.Bar.ffi.el とすれば衝突の恐れはなくなる。

+~Data/Bar.purs~ が内部で ~foreign~ を使っている場合、+
+~Data/Bar.el~ に書かれたelispを ~ps-data-bar.el~ の下部にインライン展開する。+
+foreign定義が正しく書かれているかどうかの検証は行なわない。+

+foreign定義を別ファイル、例えば ~ps-data-bar-foreign.el~ というファイルに分けた場合、+
+~Data/Bar/Foreign.purs~ モジュールが生成する通常 elファイルと衝突しないように+
+通常生成ファイルもsuffix付き、例えば ~ps-data-bar-foreign-default.el~, にする必要が出てくる。+
+インライン展開にすることで問題になることはないはずなのでインライン展開で。+

* 設計
** モジュール

Data.Bar というPSモジュールは ~ps-data-bar.el~ ファイルに
また定義英 fooBar

elispはモジュール毎に名前空間が分かれていないため、PSで定義する関数をそのままelispの関数名としては使えない。
そもそもが PSではキャメルケース、elispではハイフン区切りと命名規約が異なっている。
そのため elispのモジュール名を prefix に付ける。
~Data.Bar~ の ~foo~ 関数であれば ~ps-data-bar.foo~ である。

** モジュール内トップレベル処理

elisp はモジュールの最後でトップレベルの処理を書いていることが多い。
拡張子とメジャーモードの対応付けを行なうなどの初期化処理を行なう。

これは行儀が悪くユーザの意図していないコードや設定が成されることがある。
モジュールをrequireした側が必要に応じて呼出すべきである。
そのためモジュール内トップレベル処理を書けないよう
foriegnファイルにトップレベルの処理を書くという抜け道があるが 絶対やるなよ!

*懸念*
モジュール内トップレベル処理は(loadではなくrequireする限り)初期化処理が一度のみ走ることが保証される。
モジュールを require する側が必要に応じて呼出しでは複数回実行されてしまう可能性がある。
あまりに大変な場合であれば設計を変える必要がある。

** 関数

elispでは関数の値の名前空間が分かれていること考慮する必要がある。
具体的には各シンボルは値を格納するスロット(setq)と、関数を格納するスロット(fset)の二つのスロットを持つ。
~(define foo (..args..) ..)~ によって関数を定義すると ~foo~ シンボル関数スロットに関数が格納される。
~(defvar foo (lambda (..args..) ..)~ だと ~foo~ の値スロットに関数が格納される。
関数呼出し ~(foo ...)~ を行なうと関数スロットに格納されている値を用いて呼出される。

それを踏まえた上で

#+begin_src purescript
foo :: Int -> Int -> Int
foo a b = a + b
#+end_src

1)
#+begin_src emacs-lisp
(defun ps-data-bar.foo (a b) (+ a b))
#+end_src

2)
#+begin_src emacs-lisp
(defvar foo (lambda (a b) (+ a b)))
#+end_src

3)
#+begin_src emacs-lisp
(defvar foo (lambda (a) (lambda (b) (+ a b))))
#+end_src

elisp コードとして一番自然なのは 1)である。
残念ながら上記スロットの問題と部分適用を考えると 3) を採用する必要がある。
ただ最適化は可能。一旦保留で。

** 文字列
*** 内部表現問題

elisp文字列は unibyte と multibyte の二つの表現を持つ。
unibyteは任意のバイト列であり、1バイトが1文字と解釈される(ByteString.Char8 っぽい)。
multibyteはバイト列をUTF-8(厳密はにはちょっと違うらしいが)と解釈する。

内部表現によって文字列型を分けるか?
それは分けなかった場合危険で、分けることによって安全になるのか？
分けなかった場合に起こりうる問題を考える。
有り得る問題としては

 * 異なる内部表現同士の演算だと例外が発生する、
 * 特定の内部表現しか受け付けないような関数がある、

など。もっと一般化して言えば：

  文字列を受け取る関数・演算が内部表現によってセマンティクスが変わるものがあるか？

ということ。

分からんので取り敢えず何も考えず一つで。

参照
https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-Characters.html

** 文字
https://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html

文字リテラル構文(e.g. ?a)はあるが、文字列型はなく単なる整数である。
~charaterp~ はあるが一定範囲内の整数であることしか見ていない。

: (integerp ?あ)        #=> 5
: (characterp ?あ)      #=> t
: (characterp 1000000)  #=> t
: (characterp 10000000) #=> nil

PSの文字列リテラルをelispに変換する際はelispの文字リテラル構文を使うのが自然
(恐らく特殊文字回りで諸々考慮すべきことは出てくるだろうが)。
elispの関数を呼出してopaqueな値を受け取った場合、
整数と文字の判別がつかないがこれはしょうがないか...(Objectにもこの問題が発生する)。
区別付けようとタグ付きの値とか作るとelispとの親和性が悪くなるから止めよう。

** オブジェクト

alist かな。Recordはあるが、名前参照するものではない。

: ObjectLiteral [(PSString, a)]
: Accessor a PSString (Expr a)
: ObjectUpdate a (Expr a) [(PSString, Expr a)]

https://github.com/purescript/purescript/issues/4020

** 中間表現

CoreFnの情報(Module Ann)を最終的には elispコードに変換するわけなのだが、
~Module Ann -> Text~ するわけもなく一旦 elisp の表現に落し込む(Exp型とする)。
Exp型どの程度落し込んだ型(S式か、Letなどがコンストラクトとあるような型)にするにしても、
中間表現に対して最適化等行なわないのであれば、落とし込み程度は責務の分離のみに関係する(はず)。

S式で良い気がしてきた。
そこまで落し込まなかったら CoreFn(Module Ann)とほぼ同じになってしまう。

** data

コンスラクタを表現するシンボルを先頭に、後はパラメータを格納したVectorで表現するかな。
値としてはどのデータ型なのか、どのモジュールに属するかの情報が落ちるが、
デバッグ目的以外では意味がないのであまり気にしない。
例えば Bar.For モジュールの data Hoge = A というデータ型&コンストラクタがあった場合、
Aだけが値に含まれ Bar.For, Hoge がなくなるが、
CASEで取り出す際コンストラク名だけで十分なので(型があっていることはPSコンパイラが保証するので)。
まあ型名も追跡性のため含めてもいいかもしれないが。

** newtype

newtypeはコンパイル時だけの存在かと思いきやCoreFnに存在する。
コンストラクタが identity関数に置き換わる。なるほどなー。

例えば

#+begin_src purescript
newtype Bar = Bar Int
foo = Bar
#+end_src

のコードは以下のように変換される。
Barコンストラクタはtop-level関数と同じ扱いになる。

#+begin_example
ModuleName "Main"
NonRec ()
    ( Ident "Bar" )
    ( Abs ()
        ( Ident "x" )
        ( Var ()
            ( Qualified Nothing
                ( Ident "x" )
            )
        )
    )
NonRec ()
    ( Ident "foo" )
    ( Var ()
        ( Qualified
            ( Just
                ( ModuleName "Main" )
            )
            ( Ident "Bar" )
        )
    )
#+end_example

気を付ける必要があるのは Case 。例えば次のようにcase ofを使った場合、

#+begin_src purescript
foo = case Bar 4 of
  Bar i -> i
#+end_src

実際 case of で対象となるのは4という整数なのだが、CoreFnでは次のように出力される。

#+begin_example
        ( Case ()
            [ Var ()
                ( Qualified Nothing
                    ( Ident "v" )
                )
            ]
            [ CaseAlternative
                { caseAlternativeBinders =
                    [ ConstructorBinder ()
                        ( Qualified
                            ( Just
                                ( ModuleName "Main" )
                            )
                            ( ProperName
                                { runProperName = "Bar" }
                            )
                        )
                        ( Qualified
                            ( Just
                                ( ModuleName "Main" )
                            )
                            ( ProperName
                                { runProperName = "Bar" }
                            )
                        )
                        [ VarBinder ()
                            ( Ident "i" )
                        ]
                    ]
                , caseAlternativeResult = Right
                    ( Var ()
                        ( Qualified Nothing
                            ( Ident "i" )
                        )
                    )
                }
            ]
        )
#+end_example

つまり *data型と変わらない* 。なので ConstructorBinderだけでは出力すべき S式は定まらず、
アノテーション情報Annを見て newtype かどうかを判断する必要がある。
purenixでもそのようにしてコードを出力している。

#+begin_src haskell
unbinder (ConstructorBinder (_, _, _, Just IsNewtype) _ _ [field]) scrut = unbinder field scrut
unbinder (ConstructorBinder ann _ (P.Qualified _ (P.ProperName tag)) fields) scrut =
    localAnn ann $
#+end_src

** case of

 * Object Literal Binder
   - +Objectを alist に対応させている場合、フィールドの順序が問題になってくる+
   - +alistを常にソートするか？+
   - 順序も違うし、部分的にしか指定されない場合がある
   - and と色々組み合わせたらいけるのかな？
   - ‘(app FUNCTION PATTERN)’ と and の組合せでいけた
     #+begin_src elisp
     (pcase '[((a . 1) (b . 3) (c . "foo"))]
       (`[,(and (app (lambda (v) (cdr (assq 'c v)))
                     v0)
                (app (lambda (v) (cdr (assq 'a v)))
                     1)
                )]
        v0))
     #+end_src
 * Array Literal
   - OK
   : (pcase [1 2] (`[,a 2] a))
 * asパターン(NamedBinder)
   - (and <ident> ...) を使えばいける
   : (pcase [1 2] ((and v `[,a 2]) v))
 * ConstructorBinder

PSは不完全マッチでもコンパイル通る。

* CoreFn(Module Ann)についてのメモ
https://hackage.haskell.org/package/purescript-0.13.8/docs/Language-PureScript-CoreFn-Expr.html#t:Expr
** Constructor a (ProperName TypeName) (ProperName ConstructorName) [Ident]

Constructorはデータ型定義の際に使われる。
各コンストラクタ毎にtop-levelのbindingで使われる(下記(1)(2))。
コンストラクタで値を組み立てる際はコストラクタ名で参照する(下記(3))。
~[Ident]~ は自動で割当てられる名前で使わないので無視していい(ただパラメータ数を把握するのに必要)。

#+begin_src purescript
data Foo = A Int String | B
foo = A
#+end_src

#+begin_example
ModuleName "Main"
NonRec ()                                     -- (1)
    ( Ident "A" )
    ( Constructor ()
        ( ProperName
            { runProperName = "Foo" }
        )
        ( ProperName
            { runProperName = "A" }
        )
        [ Ident "value0"
        , Ident "value1"
        ]
    )
NonRec ()                                     -- (2)
    ( Ident "B" )
    ( Constructor ()
        ( ProperName
            { runProperName = "Foo" }
        )
        ( ProperName
            { runProperName = "B" }
        ) []
    )
NonRec ()
    ( Ident "foo" )
    ( Var ()
        ( Qualified
            ( Just
                ( ModuleName "Main" )
            )
            ( Ident "A" )                     -- (3)
        )
    )
#+end_example

** Case a [Expr a] [CaseAlternative a]

何故 ~[Expr a]~ って複数あるのか？
二番目の型パラメータは case が対象とする引数の型。
なのでリストではなく単一の ~Expr a~ かと思っていたのだが...
複数あるケースがあるのか？？または0個のケースも..

https://github.com/purescript/documentation/blob/master/language/Syntax.md#case-expressions
-> 複数ありなんだ...

#+begin_src purescript
f :: Maybe Boolean -> Either Boolean Boolean -> String
f a b = case a, b of
  Just true, Right true -> "Both true"
  Just true, Left _ -> "Just is true"
  Nothing, Right true -> "Right is true"
  _, _ -> "Both are false"
f (Just true) (Right true)
#+end_src

guard節もちゃんと対応する必要あり
#+begin_src purescript
f :: Either Int Unit -> String
f x = case x of
  Left x | x == 0 -> "Left zero"
         | x < 0 -> "Left negative"
         | otherwise -> "Left positive"
  Right _ -> "Right"
#+end_src

#+begin_src purescript
data CaseAlternative a = CaseAlternative
  { -- |
    -- A collection of binders with which to match the inputs
    --
    caseAlternativeBinders :: [Binder a]
    -- |
    -- The result expression or a collect of guarded expressions
    --
  , caseAlternativeResult :: Either [(Guard a, Expr a)] (Expr a)
  }
#+end_src



#+begin_src purescript
-- |
-- Data type for binders
--
data Binder a
  -- |
  -- Wildcard binder
  --
  = NullBinder a
  -- |
  -- A binder which matches a literal value
  --
  | LiteralBinder a (Literal (Binder a))
  -- |
  -- A binder which binds an identifier
  --
  | VarBinder a Ident
  -- |
  -- A binder which matches a data constructor
  --
  | ConstructorBinder a (Qualified (ProperName 'TypeName)) (Qualified (ProperName 'ConstructorName)) [Binder a]
  -- |
  -- A binder which binds its input to an identifier
  --
  | NamedBinder a Ident (Binder a)
#+end_src

** top-level bind(moduleDeclsのBind)にRecは入りえるのか？

入ってきた。
+ただその場合でもリストは長さ必ず1っぽい。+

相互再帰であれば2以上のRecなTopLevelBidningがありうる。

: foo :: Int -> Int
: foo i = if i < 0 then bar i else 4
:
: bar :: Int -> Int
: bar i = if i > 0 then foo i else 5

まあ、動的型をターゲットとする場合定義順は関係なので単にflattenすればいい。

** Var a (Qualified Ident): 同モジュール内top-levelな定義参照時もQualifiedされるか？

yes!

#+begin_src purescript
foo = 1
bar = foo
#+end_src

#+begin_example
NonRec ()
    ( Ident "foo" )
    ( Literal ()
        ( NumericLiteral
            ( Left 1 )
        )
    )
NonRec ()
    ( Ident "bar" )
    ( Var ()
        ( Qualified
            ( Just
                ( ModuleName "Main" )
            )
            ( Ident "foo" )
        )
    )
#+end_example

** Let a [Bind a] (Expr a)

binding順序とRec/NonRecのルール。
NonRec というのは既に束縛したものにしか依存しない。
Rec の集合は互いに依存しあう(つまる順序が決まらない)。

両方ともNonRec
: foo =
:   let a = 1
:       b = a
:   in a + b

両方とも NonRec (ただし b が先に来る)
: foo =
:   let a = b
:       b = 2
:   in a + b

a だけ先にRec, b は NonRec
: foo =
:   let a v = a v
:       b v = a v
:   in a >>> b

両方ともRec
: foo =
:   let a v = b v
:       b v = a v
:   in a >>> b

* 将来

PureScript -> elisp 以外にも PureScript -> JS(emacs-ng) や PureScript -> C?native code (emacs dynamic module) の方向性も模索したいところ。
後々移行できる設計したい。

* 参考

https://github.com/purenix-org/purenix
